[{"title":"算法模板","path":"/2024/04/23/算法模板/","content":"12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;private: int n = 200005; // 节点数量 20000 vector&lt;int&gt; father = vector&lt;int&gt; (n, 0); // C++里的一种数组结构 // 并查集初始化 void init() &#123; for (int i = 0; i &lt; n; ++i) &#123; father[i] = i; &#125; &#125; // 并查集里寻根的过程 int find(int u) &#123; return u == father[u] ? u : father[u] = find(father[u]); &#125; // 判断 u 和 v是否找到同一个根 bool isSame(int u, int v) &#123; u = find(u); v = find(v); return u == v; &#125; // 将v-&gt;u 这条边加入并查集 void join(int u, int v) &#123; u = find(u); // 寻找u的根 v = find(v); // 寻找v的根 if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回 father[v] = u; &#125;public: bool validPath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int source, int destination) &#123; init(); for (int i = 0; i &lt; edges.size(); i++) &#123; join(edges[i][0], edges[i][1]); &#125; return isSame(source, destination); &#125;&#125;; 通过模板，我们可以知道，并查集主要有三个功能。 寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个 将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上 判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点"},{"title":"MySQL","path":"/2024/04/12/MySQL/","content":"主键表中的任何列都可以作为主键，只要它满足以下条件： 任意俩行都不具有相同的主键值 每一行都必须具有一个主键值（主键列不允许空值NULL） 主键列中的值不允许修改或更新 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行） SELECT语句从一个或多个表中检索信息。 多条SQL 语句必须以分号（；）分隔。 SQL 语句不区分大小写，因此SELECT 与select 是相同的。 检索单个列输入： 12SELECT prod_nameFROM Products; 上述语句利用SELECT 语句从Products 表中检索一个名为prod_name的列 检索多个列在SELECT 关键字后给出多个列名，列名之间必须以逗号分隔。 输入： 12SELECT prod_id,prod_name,prod_priceFROM Profucts; 检索所有列12SELECT *FROM Products; 检索不同的值输入 12SELECT DISTINCT ven_idFROM Products; SELECT DISTINCT vend_id 告诉DBMS 只返回不同（具有唯一性）的vend_id 行，所以正如下面的输出，只有3 行。如果使用DISTINCT 关键字，它必须直接放在列名的前面。 输出 12345vend_id----------BRS01DLL01FNG01 限制结果在SQL Server 中使用SELECT 时，可以用TOP 关键字来限制最多返回多少行，如下所示： 输入： 12SELECT TOP 5 prod_nameFROM Products; 输出 1234567prod_name-----------------8 inch teddy bear12 inch teddy bear18 inch teddy bearFish bean bag toyBird bean bag toy 如果你使用MySQL、MariaDB、PostgreSQL 或者SQLite，需要使用LIMIT子句，像这样： 123SELECT prod_nameFROM ProductsLIMIT 5; 注释输入： 123456789SELECT prod_name -- 这是一条注释# 这是一条注释/*多行注释SELECT prod_nameFROM ProductsLIMIT 5;*/FROM Products; 排序检索ORDER BY子句取一个或多个列的名字，据此对输出进行排序。请看下面的例子： 输入： 123SELECT prod_nameFROM ProductsORDER BY prod_name; 除了指示DBMS 软件对prod_name 列以字母顺序排序数据的ORDER BY子句外，这条语句与前面的语句相同。结果如下。 注意： ORDER BY 子句的位置在指定一条ORDER BY 子句时，应该保证它是SELECT 语句中最后一条子句。如果它不是最后的子句，将会出错。 按多个列排序输入： 123SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY prod_price, prod_name; 按列位置排序除了能用列名指出排序顺序外，ORDER BY 还支持按相对列位置进行排序。为理解这一内容，我们来看个例子： 123SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY 2, 3; 指定排序方向输入： 123SELECT prod_id, prod_price, prod_nameFROM ProductsORDER BY prod_price DESC prod_name; DESC 关键字只应用到直接位于其前面的列名。在上例中，只对prod_price列指定DESC，对prod_name 列不指定。因此，prod_price 列以降序排序，而prod_name 列（在每个价格内）仍然按标准的升序排序。 注意： 如果想在多个列上进行降序排序，必须对每一列指定DESC 关键字。 过滤数据使用WHERE子句WHERE 子句在表名（FROM 子句）之后给出，如下所示： 输入： 123SELECT prod_name, prod_priceFROM ProductsWHERE prod_price = 3.49; 注意：WHERE 子句的位置在同时使用ORDER BY 和WHERE 子句时，应该让ORDER BY 位于WHERE 之后，否则将会产生错误 WHERE子句操作符 操作符 说明 &#x3D; 等于 &lt; &gt; 不等于 !&#x3D; 不等于 &lt; 小于 &lt;&#x3D; 小于等于 !&lt; 不小于 &gt; 大于 &gt;&#x3D; 大于等于 !&gt; 不大于 BETWEEN 在指定的俩个值之间 IS NULL 为NULL值 如果将值与字符串类型的列进行比较，就需要限定引号。用来与数值列进行比较的值不用引号。 范围值检查要检查某个范围的值，可以使用BETWEEN 操作符 输入： 123SELECT prod_name, prod_priceFROM ProductsWHERE prod_price BETWEEN 5 AND 10; 空值检查在创建表时，表设计人员可以指定其中的列能否不包含值。在一个列不包含值时，称其包含空值NULL。 123SELECT prod_nameFROM ProductsWHERE prod_price IS NULL; 高级数据过滤AND操作符要通过不止一个列进行过滤，可以使用AND 操作符给WHERE 子句附加条件。下面的代码给出了一个例子： 输入： 123SELECT prod_id, prod_price, prod_nameFROM ProductsWHERE vend_id = &#x27;DLL01&#x27; AND prod_price &lt;= 4; OR操作符123SELECT prod_id, prod_price, prod_nameFROM ProductsWHERE vend_id = &#x27;DLL01&#x27; OR vend_id = &#x27;BRS01&#x27;; 求值顺序1234SELECT prod_name, prod_priceFROM ProductsWHERE (vend_id = &#x27;DLL01&#x27; OR vend_id = &#x27;BRS01&#x27;)AND prod_price &gt;= 10; IN操作符1234SELECT prod_name, prod_priceFROM ProductsWHERE vend_id IN (&#x27;DLL01&#x27;,&#x27;BRS01&#x27;)ORDER BY prod_name; 与OR完成相同的功能 优点： 在有很多合法选项时，IN 操作符的语法更清楚，更直观。 在与其他AND 和OR 操作符组合使用IN 时，求值顺序更容易管理。 IN 操作符一般比一组OR 操作符执行得更快（在上面这个合法选项很少的例子中，你看不出性能差异）。 IN 的最大优点是可以包含其他SELECT 语句，能够更动态地建立 WHERE 子句。第11 课会对此进行详细介绍。 NOT操作符1234SELECT prod_nameFROM ProductsWHERE NOT vend_id = &#x27;DLL01&#x27;ORDER BY prod_name; 用通配符进行过滤LIKE操作符百分号（%）通配符最常使用的通配符是百分号（%）。在搜索串中，%表示任何字符出现任意次数。例如，为了找出所有以词Fish 起头的产品，可写以下的SELECT 语句： 输入： 123SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE &#x27;Fish%&#x27;; 输出： 123prod_id prod_name------- ------------------BNBG01 Fish bean bag toy 输入： 123SELECT prod_id, prod_nameFROM ProductsWHERE prod_name LIKE &#x27;%bean bag%&#x27;; 输出： 12345prod_id prod_name-------- --------------------BNBG01 Fish bean bag toyBNBG02 Bird bean bag toyBNBG03 Rabbit bean bag toy 注意：请注意NULL通配符%看起来像是可以匹配任何东西，但有个例外，这就是NULL。子句WHERE prod_name LIKE ‘%’不会匹配产品名称为NULL 的行 下划线（_）通配符它只匹配单个字符，而不是多个字符。 方括号([])通配符方括号（[]）通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符。 输入： 1234SELECT cust_contactFROM CustomersWHERE cust_contact LIKE &#x27;[JM]%&#x27;ORDER BY cust_contact; 输出： 12345cust_contact-----------------Jim JonesJohn SmithMichelle Green 此通配符可以用前缀字符^（脱字号）来否定。例如，下面的查询匹配以J 和M 之外的任意字符起头的任意联系人名（与前一个例子相反）： 输入： 1234SELECT cust_contactFROM CustomersWHERE cust_contact LIKE &#x27;[^JM]%&#x27;ORDER BY cust_contact; 当然，也可以使用NOT 操作符得出类似的结果。^ 的唯一优点是在使用多个WHERE 子句时可以简化语法： 输入： 1234SELECT cust_contactFROM CustomersWHERE NOT cust_contact LIKE &#x27;[JM]%&#x27;ORDER BY cust_contact; 创建计算字段拼接字段在SQL 中的SELECT 语句中，可使用一个特殊的操作符来拼接两个列。根据你所使用的DBMS，此操作符可用加号（+）或两个竖杠（||）表示。在MySQL 和MariaDB 中，必须使用特殊的函数。 SQL Server 使用+号。DB2、Oracle、PostgreSQL 和SQLite 使用||。详细请参阅具体的DBMS 文档。 输入： 123SELECT RTRIM(vend_name) + &#x27; (&#x27; + RTRIM(vend_country) + &#x27;)&#x27;FROM VendorsORDER BY vend_name; 输出： 1234567-----------------------------------------------------------Bear Emporium (USA)Bears R Us (USA)Doll House Inc. (USA)Fun and Games (England)Furball Inc. (USA)Jouets et ours (France) RTRIM()函数去掉值右边的所有空格。通过使用RTRIM()，各个列都进行了整理 输入： 1234SELECT RTRIM(vend_name) + &#x27; (&#x27; + RTRIM(vend_country) + &#x27;)&#x27;AS vend_titleFROM VendorsORDER BY vend_name; 输出： 12345678vend_title-----------------------------------------------------------Bear Emporium (USA)Bears R Us (USA)Doll House Inc. (USA)Fun and Games (England)Furball Inc. (USA)Jouets et ours (France) 执行算术计算输入： 123456SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_priceFROM OrderItemsWHERE order_num = 20008; 输出： 1234567prod_id quantity item_price expanded_price---------- ----------- ------------ -----------------RGAN01 5 4.9900 24.9500BR03 5 11.9900 59.9500BNBG01 10 3.4900 34.9000BNBG02 10 3.4900 34.9000BNBG03 10 3.4900 34.9000 使用函数处理数据文本处理函数输入： 123SELECT vend_name, UPPER(vend_name) AS vend_name_upcaseFROM VendorsORDER BY vend_name; 输出： 12345678vend_name vend_name_upcase--------------------------- ----------------------------Bear Emporium BEAR EMPORIUMBears R Us BEARS R USDoll House Inc. DOLL HOUSE INC.Fun and Games FUN AND GAMESFurball Inc. FURBALL INC.Jouets et ours JOUETS ET OURS UPPER()将文本转换大写 函数 说明 LEFT()（或使用子字符串函数） 返回字符串左边的字符 LENGTH()（也使用DATALENGTH()或LEN()） 返回字符串的长度 LOWER() 将字符串转换为小写 LTRIM() 去掉字符串左边的空格 RIGHT()（或使用子字符串函数） 返回字符串右边的字符 RTRIM() 去掉字符串右边的空格 SUBSTR()或SUBSTRING() 提取字符串的组成部分 SOUNDEX() 返回字符串的SOUNDEX值 UPPER() 将字符串转换为大写 日期和时间处理函数输入： 123SELECT order_numFROM OrdersWHERE DATEPART(yy, order_date) = 2020; 输出： 1234567order_num-----------2000520006200072000820009 数值处理函数 函数 说明 ABS() 返回一个数的绝对值 COS() 返回一个角度的余弦 EXP() 返回一个数的指数值 PI() 返回圆周率π 的值 SIN() 返回一个角度的正弦 SQRT() 返回一个数的平方根 TAN() 返回一个角度的正切 汇总数据聚集函数 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 输入： 12SELECT AVG(prod_price) AS avg_priceFROM Products; 输出： 123avg_price-------------6.823333 聚集不同值组合聚集函数 输入： 12345SELECT COUNT(*) AS num_items,MIN(prod_price) AS price_min,MAX(prod_price) AS price_max,AVG(prod_price) AS price_avgFROM Products; 分组数据数据分组比如下面的例子返回供应商DLL01 提供的产品数目： 输入： 123SELECT COUNT(*) AS num_prodsFROM ProductsWHERE vend_id = &#x27;DLL01&#x27;; 输出： 123num_prods-----------4 创建分组输入： 123SELECT vend_id, COUNT(*) AS num_prodsFROM ProductsGROUP BY vend_id; 过滤分组输入： 1234SELECT cust_id, COUNT(*) AS ordersFROM OrdersGROUP BY cust_idHAVING COUNT(*) &gt;= 2; 分组和排序SELECT子句顺序 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 分组说明 否 ORDER BY 输出排序顺序 否 使用子查询在SELECT 语句中，子查询总是从内向外处理。在处理上面的SELECT 语句时，DBMS 实际上执行了两个操作。 联结表联结输入： 123SELECT vend_name, prod_name, prod_priceFROM Vendors, ProductsWHERE Vendors.vend_id = Products.vend_id; 内联结输入： 123SELECT vend_name, prod_name, prod_priceFROM VendorsINNER JOIN Products ON Vendors.vend_id = Products.vend_id; 联结多个表12345SELECT prod_name, vend_name, prod_price, quantityFROM OrderItems, Products, VendorsWHERE Products.vend_id = Vendors.vend_idAND OrderItems.prod_id = Products.prod_idAND order_num = 20007; 创建高级联结使用表别名输入： 12345SELECT cust_name, cust_contactFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_idAND OI.order_num = O.order_numAND prod_id = &#x27;RGAN01&#x27;; 使用不同类型的联结自联结1234SELECT c1.cust_id, c1.cust_name, c1.cust_contactFROM Customers AS c1, Customers AS c2WHERE c1.cust_name = c2.cust_nameAND c2.cust_contact = &#x27;Jim Jones&#x27;; 提示：Oracle 中没有ASOracle 用户应该记住去掉AS。 自然联结1234567SELECT C.*, O.order_num, O.order_date,OI.prod_id, OI.quantity, OI.item_priceFROM Customers AS C, Orders AS O,OrderItems AS OIWHERE C.cust_id = O.cust_idAND OI.order_num = O.order_numAND prod_id = &#x27;RGAN01&#x27;; 外联结123SELECT Customers.cust_id, Orders.order_numFROM CustomersLEFT OUTER JOIN Orders ON Customers.cust_id = Orders.cust_id; 组合查询1234567SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN (&#x27;IL&#x27;,&#x27;IN&#x27;,&#x27;MI&#x27;)UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = &#x27;Fun4All&#x27;; 对组合查询结果排序12345678SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN (&#x27;IL&#x27;,&#x27;IN&#x27;,&#x27;MI&#x27;)UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = &#x27;Fun4All&#x27;ORDER BY cust_name, cust_contact;xxxxxxxxxx SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN (&#x27;IL&#x27;,&#x27;IN&#x27;,&#x27;MI&#x27;)UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = &#x27;Fun4All&#x27;ORDER BY cust_name, cust_contact;[]() 插入数据插入完整的行12345678910INSERT INTO CustomersVALUES(1000000006,&#x27;Toy Land&#x27;,&#x27;123 Any Street&#x27;,&#x27;New York&#x27;,&#x27;NY&#x27;,&#x27;11111&#x27;,&#x27;USA&#x27;,NULL,NULL); 123456789101112131415161718INSERT INTO Customers(cust_id,\tcust_name,\tcust_address,\tcust_city,\tcust_state,\tcust_zip,\tcust_country,\tcust_contact,\tcust_email)VALUES(1000000006,\t&#x27;Toy Land&#x27;,\t&#x27;123 Any Street&#x27;,\t&#x27;New York&#x27;,\t&#x27;NY&#x27;,\t&#x27;11111&#x27;,\t&#x27;USA&#x27;,\tNULL,\tNULL); 插入部分行1234567891011121314INSERT INTO Customers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)VALUES(1000000006,&#x27;Toy Land&#x27;,&#x27;123 Any Street&#x27;,&#x27;New York&#x27;,&#x27;NY&#x27;,&#x27;11111&#x27;,&#x27;USA&#x27;); 插入检索出来的值12345678910111213141516171819INSERT INTO Customers(cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)SELECT cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_countryFROM CustNew; 从一个表复制到另一个表1CREATE TABLE CustCopy AS SELECT * FROM Customers; 使用SQL Server 1SELECT * INTO CustCopy FROM Customers; 更新和删除数据更新数据1234UPDATE CustomersSET cust_contact = &#x27;Sam Roberts&#x27;,cust_email = &#x27;sam@toyland.com&#x27;WHERE cust_id = 1000000006; 删除数据12DELETE FROM CustomersWHERE cust_id = 1000000006; 创建和操纵表创建表12345678CREATE TABLE Products(prod_id CHAR(10) NOT NULL,vend_id CHAR(10) NOT NULL,prod_name CHAR(254) NOT NULL,prod_price DECIMAL(8,2) NOT NULL,prod_desc VARCHAR(1000) NULL); 指定默认值12345678CREATE TABLE OrderItems(order_num INTEGER NOT NULL,order_item INTEGER NOT NULL,prod_id CHAR(10) NOT NULL,quantity INTEGER NOT NULL DEFAULT 1,item_price DECIMAL(8,2) NOT NULL); 更新表12ALTER TABLE VendorsADD vend_phone CHAR(20); 删除表1DROP TABLE CustCopy; 重命名表每个DBMS 对表重命名的支持有所不同。对于这个操作，不存在严格的标准。DB2、MariaDB、MySQL、Oracle 和PostgreSQL 用户使用RENAME语句，SQL Server 用户使用sp_rename 存储过程，SQLite 用户使用ALTER TABLE 语句。 使用视图12345CREATE VIEW ProductCustomers ASSELECT cust_name, cust_contact, prod_idFROM Customers, Orders, OrderItemsWHERE Customers.cust_id = Orders.cust_idAND OrderItems.order_num = Orders.order_num; 123SELECT cust_name, cust_contactFROM ProductCustomersWHERE prod_id = &#x27;RGAN01&#x27;; 用视图重新格式化检索出的数据1234CREATE VIEW VendorLocations ASSELECT RTRIM(vend_name) + &#x27; (&#x27; + RTRIM(vend_country) + &#x27;)&#x27;AS vend_titleFROM Vendors; 用视图过滤不想要的数据1234CREATE VIEW CustomerEMailList ASSELECT cust_id, cust_name, cust_emailFROM CustomersWHERE cust_email IS NOT NULL; 使用视图与计算字段123456SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_priceFROM OrderItemsWHERE order_num = 20008; 使用存储过程1234EXECUTE AddNewProduct(&#x27;JTS01&#x27;,&#x27;Stuffed Eiffel Tower&#x27;,6.49,&#x27;Plush stuffed toy with the text La Tour Eiffel in red white and blue&#x27;); 创建存储过程1234567891011CREATE PROCEDURE MailingListCount (ListCount OUT INTEGER)ISv_rows INTEGER;BEGINSELECT COUNT(*) INTO v_rowsFROM CustomersWHERE NOT cust_email IS NULL;ListCount := v_rows;END; 1234567891011121314CREATE PROCEDURE NewOrder @cust_id CHAR(10)AS-- 为订单号声明一个变量DECLARE @order_num INTEGER-- 获取当前最大订单号SELECT @order_num=MAX(order_num)FROM Orders-- 决定下一个订单号SELECT @order_num=@order_num+1-- 插入新订单INSERT INTO Orders(order_num, order_date, cust_id)VALUES(@order_num, GETDATE(), @cust_id)-- 返回订单号RETURN @order_num; 管理事务处理控制事务处理123BEGIN TRANSACTION...COMMIT TRANSACTION 使用ROLLBACKSQL 的ROLLBACK 命令用来回退（撤销）SQL 语句， 12DELETE FROM Orders;ROLLBACK; 使用COMMIT1234BEGIN TRANSACTIONDELETE OrderItems WHERE order_num = 12345DELETE Orders WHERE order_num = 12345COMMIT TRANSACTION 使用保留点12SAVEPOINT delete1;ROLLBACK TRANSACTION delete1; 12345678910111213141516BEGIN TRANSACTIONINSERT INTO Customers(cust_id, cust_name)VALUES(1000000010, &#x27;Toys Emporium&#x27;);SAVE TRANSACTION StartOrder;INSERT INTO Orders(order_num, order_date, cust_id)VALUES(20100,&#x27;2001/12/1&#x27;,1000000010);IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;INSERT INTO OrderItems(order_num, order_item,➥prod_id, quantity, item_price)VALUES(20100, 1, &#x27;BR01&#x27;, 100, 5.49);IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;INSERT INTO OrderItems(order_num, order_item,➥prod_id, quantity, item_price)VALUES(20100, 2, &#x27;BR03&#x27;, 100, 10.99);IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;COMMIT TRANSACTION 这里的事务处理块中包含了4 条INSERT 语句。在第一条INSERT 语句之后定义了一个保留点，因此，如果后面的任何一个INSERT 操作失败，事务处理能够回退到这里。在SQL Server 中，可检查一个名为@@ERROR的变量，看操作是否成功。（其他DBMS 使用不同的函数或变量返回此信息。）如果@@ERROR 返回一个非0 的值，表示有错误发生，事务处理回退到保留点。如果整个事务处理成功，发布COMMIT 以保留数据。 使用游标创建游标1234DECLARE CustCursor CURSORFORSELECT * FROM CustomersWHERE cust_email IS NULL; 使用游标12OPEN CURSOR CustCursorCLOSE CustCursor"}]